package Visibility;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: ThreadLearn
 * @description: 内存可见性
 * @author: Mr.Yqy
 * @create: 2019-03-24 12:35
 **/
public class Visibility {
    /**
     * 可见性：一个线程对共享变量值的修改，能够及时地被其他线程看到
     * 共享变量：一个变量如果在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量
     * JMM（java内存模型）关于此部分的个人理解:一个进程有一个主内存，而其中的线程各自拥有自己的工作内存，对于主内存和线程所共同拥有的数据，
     * 每个线程在自己的工作内存中都有对该数据在主内存中的一份拷贝
     *
     * 注意：
     * 1.线程对共享变量的具体操作都必须在自己的工作内存中进行，不能直接对主内存中的该变量直接进行读写。
     * 2.不同线程之间无法直接访问对方工作内存之间的变量，线程间变量的传递需要通过主内存来进行
     *
     */


    /**
     * 实现线程可见性：
     * 如果线程1中修改了一个变量，想被线程2看到，需要经过如下步骤：
     * 1.把内存1中更新过的共享变量刷新到主内存中
     * 2.将主内存中最新的共享变量值更新到工作内存2中
     */


    /**接下来介绍第一种具体的实现可见性的方式：
     * 1.synchronized :原子性（同步） 可见性
     * JMM中关于synchronized中的两条规定：
     * （1）线程解锁前必须吧共享变量的最新值刷新到主内存中
     * （2）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值
     *
     * 2.线程执行互斥代码的过程：
     * （1）获得互斥锁
     * （2）清空工作内存
     * （3）将主内存中的变量值装载到工作内存中
     * （4）执行代码
     * 若变量发生改变
     * （5）将更改后的共享变量值刷新到主内存
     * （6）释放互斥锁
     */

    /**
     * 补充知识点：重排序
     * 重排序是代码书写的顺序与实际的执行顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化
     * 1.编译器优化的重排序
     * 2.指令集并行重排序
     * 3.内存系统的重排序
     *
     * 在数据依赖关系时会阻止重排序
     * 而逻辑依赖（比如if）不会阻止重排序
     *
     *
     */

    /**
     * 对volatile的理解：
     * 1.在进行写操作时，处理器会在操作前加入一条store屏障指令，将cpu写缓冲区的缓存刷新到主内存中，同时会阻止影响值的相关重排序
     * 2.在进行读操作时，处理器会在操作前加入一条load指令，强制使缓冲区的缓存失效
     * 3.volatile是不能保证变量的原子性的
     *
     */


     //对自增操作的２种同步写法
    public void add1(){
        int a=0;
        synchronized (this){
            a++;
        }
    }
    public void add2(){
        Lock lock=new ReentrantLock();
        lock.lock();
        //try,finally来保障锁的释放
        int a=0;
        try{
            a++;
        }catch (Exception e){
            //抛出异常
        }finally {
            lock.unlock();
        }
    }
    /**
     * 如果想要在线程中安全的使用volatile，必须同时满足
     * 1.对变量的写入操作不依赖其当前值。（如不可用++等）
     * 2.该变量不包含在具有其他变量的不变式中
     */

    /**
     * 对synchronized和volatile的比较
     * volatile不需要加锁，运行更轻量级
     * 但是volatile只能保证可见性，不能保证原子性
     * 而synchronized既可以保证可见性，又可以保证原子性
     * 如果能保证线程安全，则更推荐volatile
     *
     * 注意：共享数据访问权限都必须定义为private
     */

}
